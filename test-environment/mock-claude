#!/bin/bash
# Mock Claude for testing nigel

set -e

DELAY="${MOCK_CLAUDE_DELAY:-3}"
STREAMING=0
PROMPT=""

# Parse flags
while [[ $# -gt 0 ]]; do
    case "$1" in
        -p)
            # Check if the next arg looks like a flag (starts with -), is empty,
            # or is a heredoc (starts with <<) - in those cases, read from stdin
            if [[ -z "$2" ]] || [[ "$2" == -* ]] || [[ "$2" == "<"* ]]; then
                PROMPT=$(cat)
                shift
            else
                PROMPT="$2"
                shift 2
            fi
            ;;
        --output-format)
            if [[ "$2" == "stream-json" ]]; then
                STREAMING=1
            fi
            shift 2
            ;;
        --print|--include-partial-messages|--verbose)
            shift
            ;;
        *)
            shift
            ;;
    esac
done

# Extract candidate from prompt
CANDIDATE=$(echo "$PROMPT" | grep -oP 'Fix the issue: \K\S+' || echo "unknown")

# Response text - split into multiple message blocks
MSG1="[mock-claude] Analyzing '$CANDIDATE'..."
MSG2="I'll examine the code to identify the issue."
MSG3="Tuning: MOCK_CLAUDE_DELAY=${DELAY}s  MOCK_CLAUDE_FIX=${MOCK_CLAUDE_FIX:-0}"

if [[ "$MOCK_CLAUDE_FIX" == "1" ]]; then
    touch ".fixed-${CANDIDATE}"
    MSG4="Result: Fixed - the issue has been resolved."
else
    MSG4="Result: Not fixed - additional work needed."
fi

# Helper to stream a message chunk
stream_message() {
    local text="$1"
    local mode="${MOCK_CLAUDE_MODE:-word}"

    case "$mode" in
        tiny)
            # Stream 1 character at a time
            for ((i=0; i<${#text}; i++)); do
                char="${text:$i:1}"
                sleep 0.01
                char=$(echo "$char" | sed 's/"/\\"/g')
                echo "{\"type\":\"stream_event\",\"event\":{\"type\":\"content_block_delta\",\"index\":0,\"delta\":{\"type\":\"text_delta\",\"text\":\"${char}\"}}}"
            done
            ;;
        small)
            # Stream 2-5 characters at a time
            local chunk_size=3
            local pos=0
            while [[ $pos -lt ${#text} ]]; do
                # Vary chunk size slightly
                chunk_size=$((2 + (pos % 4)))
                local chunk="${text:$pos:$chunk_size}"
                pos=$((pos + chunk_size))
                sleep 0.02
                chunk=$(echo "$chunk" | sed 's/"/\\"/g')
                echo "{\"type\":\"stream_event\",\"event\":{\"type\":\"content_block_delta\",\"index\":0,\"delta\":{\"type\":\"text_delta\",\"text\":\"${chunk}\"}}}"
            done
            ;;
        mixed)
            # Random chunk sizes from 1-100 characters
            local pos=0
            while [[ $pos -lt ${#text} ]]; do
                local chunk_size=$((1 + (RANDOM % 100)))
                local chunk="${text:$pos:$chunk_size}"
                pos=$((pos + chunk_size))
                sleep 0.01
                chunk=$(echo "$chunk" | sed 's/"/\\"/g')
                echo "{\"type\":\"stream_event\",\"event\":{\"type\":\"content_block_delta\",\"index\":0,\"delta\":{\"type\":\"text_delta\",\"text\":\"${chunk}\"}}}"
            done
            ;;
        large)
            # Stream entire text in single chunk (simulates fast output)
            sleep 0.05
            local chunk=$(echo "$text" | sed 's/"/\\"/g')
            echo "{\"type\":\"stream_event\",\"event\":{\"type\":\"content_block_delta\",\"index\":0,\"delta\":{\"type\":\"text_delta\",\"text\":\"${chunk}\"}}}"
            ;;
        alternating)
            # Alternate between tiny and large chunks
            local pos=0
            local large=true
            while [[ $pos -lt ${#text} ]]; do
                local chunk_size
                if $large; then
                    chunk_size=50
                else
                    chunk_size=1
                fi
                large=!$large
                local chunk="${text:$pos:$chunk_size}"
                pos=$((pos + chunk_size))
                sleep 0.02
                chunk=$(echo "$chunk" | sed 's/"/\\"/g')
                echo "{\"type\":\"stream_event\",\"event\":{\"type\":\"content_block_delta\",\"index\":0,\"delta\":{\"type\":\"text_delta\",\"text\":\"${chunk}\"}}}"
            done
            ;;
        ansi)
            # Text with ANSI codes split across chunks
            local ansi_text="[1mBold[0m [3mItalic[0m [90mDim[0m ${text}"
            stream_message_impl "$ansi_text" 10
            ;;
        newlines)
            # Text with newlines at various positions
            local nl_text="Line 1\nLine 2\nLine 3\n${text}\nEnd"
            stream_message_impl "$nl_text" 5
            ;;
        rapid)
            # Very rapid tiny chunks with minimal delay
            for ((i=0; i<${#text}; i++)); do
                char="${text:$i:1}"
                sleep 0.001  # Minimal delay
                char=$(echo "$char" | sed 's/"/\\"/g')
                echo "{\"type\":\"stream_event\",\"event\":{\"type\":\"content_block_delta\",\"index\":0,\"delta\":{\"type\":\"text_delta\",\"text\":\"${char}\"}}}"
            done
            ;;
        multibyte)
            # UTF-8 multibyte characters (emoji, CJK)
            local mb_text="æ—¥æœ¬èªž ä¸­æ–‡ ðŸŽ‰ ðŸ”¥ ${text}"
            for ((i=0; i<${#mb_text}; i++)); do
                char="${mb_text:$i:1}"
                sleep 0.02
                char=$(echo "$char" | sed 's/"/\\"/g')
                echo "{\"type\":\"stream_event\",\"event\":{\"type\":\"content_block_delta\",\"index\":0,\"delta\":{\"type\":\"text_delta\",\"text\":\"${char}\"}}}"
            done
            ;;
        *)
            # Default: word-by-word streaming
            local words=($text)
            local word_count=${#words[@]}
            for ((i=0; i<word_count; i++)); do
                if [[ $i -lt $((word_count - 1)) ]]; then
                    text_chunk="${words[i]} "
                else
                    text_chunk="${words[i]}"
                fi
                sleep 0.05
                text_chunk=$(echo "$text_chunk" | sed 's/"/\\"/g')
                echo "{\"type\":\"stream_event\",\"event\":{\"type\":\"content_block_delta\",\"index\":0,\"delta\":{\"type\":\"text_delta\",\"text\":\"${text_chunk}\"}}}"
            done
            ;;
    esac
}

# Helper implementation for fixed-size chunks
stream_message_impl() {
    local text="$1"
    local chunk_size="$2"
    local pos=0
    while [[ $pos -lt ${#text} ]]; do
        local chunk="${text:$pos:$chunk_size}"
        pos=$((pos + chunk_size))
        sleep 0.02
        chunk=$(echo "$chunk" | sed 's/"/\\"/g')
        echo "{\"type\":\"stream_event\",\"event\":{\"type\":\"content_block_delta\",\"index\":0,\"delta\":{\"type\":\"text_delta\",\"text\":\"${chunk}\"}}}"
    done
}

if [[ "$STREAMING" == "1" ]]; then
    # Stream JSON format (mimics real Claude --output-format stream-json)

    # System init event
    echo '{"type":"system","subtype":"init","cwd":"/test","session_id":"mock-session","tools":[],"model":"mock-model","permissionMode":"default","claude_code_version":"test"}'

    # Check if empty message mode is enabled
    if [[ "${MOCK_CLAUDE_EMPTY_MSG:-0}" == "1" ]]; then
        # Emit an empty message (message_start â†’ message_stop with no content)
        echo '{"type":"stream_event","event":{"type":"message_start","message":{"id":"mock-msg-empty","type":"message","role":"assistant","model":"mock","content":[]}}}'
        echo '{"type":"stream_event","event":{"type":"message_stop"}}'
        # Brief pause
        sleep 0.2
    fi

    # Message 1
    echo '{"type":"stream_event","event":{"type":"message_start","message":{"id":"mock-msg-1","type":"message","role":"assistant","model":"mock","content":[]}}}'
    echo '{"type":"stream_event","event":{"type":"content_block_start","index":0,"content_block":{"type":"text","text":""}}}'
    stream_message "$MSG1"
    echo '{"type":"stream_event","event":{"type":"content_block_stop","index":0}}'
    echo '{"type":"stream_event","event":{"type":"message_stop"}}'

    # Pause between messages (longer if testing inactivity timer)
    PAUSE="${MOCK_CLAUDE_INACTIVITY_TEST:-0}"
    if [[ "$PAUSE" == "1" ]]; then
        sleep 35  # Trigger the 30-second inactivity timer
    else
        sleep 0.2
    fi

    # Message 2
    echo '{"type":"stream_event","event":{"type":"message_start","message":{"id":"mock-msg-2","type":"message","role":"assistant","model":"mock","content":[]}}}'
    echo '{"type":"stream_event","event":{"type":"content_block_start","index":0,"content_block":{"type":"text","text":""}}}'
    stream_message "$MSG2"
    echo '{"type":"stream_event","event":{"type":"content_block_stop","index":0}}'
    echo '{"type":"stream_event","event":{"type":"message_stop"}}'

    # Brief pause (normal speed after first message)
    sleep 0.2

    # Message 3
    echo '{"type":"stream_event","event":{"type":"message_start","message":{"id":"mock-msg-3","type":"message","role":"assistant","model":"mock","content":[]}}}'
    echo '{"type":"stream_event","event":{"type":"content_block_start","index":0,"content_block":{"type":"text","text":""}}}'
    stream_message "$MSG3"
    echo '{"type":"stream_event","event":{"type":"content_block_stop","index":0}}'
    echo '{"type":"stream_event","event":{"type":"message_stop"}}'

    # Brief pause
    sleep 0.2

    # Message 4
    echo '{"type":"stream_event","event":{"type":"message_start","message":{"id":"mock-msg-4","type":"message","role":"assistant","model":"mock","content":[]}}}'
    echo '{"type":"stream_event","event":{"type":"content_block_start","index":0,"content_block":{"type":"text","text":""}}}'
    stream_message "$MSG4"
    echo '{"type":"stream_event","event":{"type":"content_block_stop","index":0}}'
    echo '{"type":"stream_event","event":{"type":"message_stop"}}'

    # Final result
    FULL_RESPONSE="$MSG1 $MSG2 $MSG3 $MSG4"
    RESULT_JSON=$(echo "$FULL_RESPONSE" | sed 's/"/\\"/g' | tr '\n' ' ')
    echo "{\"type\":\"result\",\"subtype\":\"success\",\"is_error\":false,\"duration_ms\":1000,\"result\":\"${RESULT_JSON}\",\"usage\":{\"input_tokens\":10,\"output_tokens\":5}}"
else
    # Non-streaming output (original behavior)
    sleep "$DELAY"
    echo "$MSG1 $MSG2 $MSG3 $MSG4"
fi
